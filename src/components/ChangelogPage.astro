---
/**
 * ChangelogPage - 年別ページの共通コンポーネント
 *
 * トップページ（/、/codex/）と年別ページ（/{year}/、/codex/{year}/）で共通で使用。
 * 検索機能、月別グループ表示、スタイルを含む。
 */
import BaseLayout from '../layouts/BaseLayout.astro';
import SearchBox from './SearchBox.astro';
import MonthGroup from './MonthGroup.astro';
import { getLegendItems } from '../lib/legend';

interface MonthData {
  key: string;
  label: string;
  versions: any[];
}

interface Props {
  year: string;
  years: string[];
  months: MonthData[];
  generatedAt?: string;
  product?: 'claude-code' | 'codex';
}

const {
  year,
  years,
  months,
  generatedAt,
  product = 'claude-code',
} = Astro.props;

const generatedDate =
  typeof generatedAt === 'string' && Number.isFinite(Date.parse(generatedAt))
    ? new Date(generatedAt).toLocaleString('ja-JP', {
        timeZone: 'Asia/Tokyo',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
      })
    : '不明';

const productName = product === 'codex' ? 'OpenAI Codex' : 'Claude Code';

// 検索モード保持キー（プロダクト別）
const storageKey = `ccclog.searchMode.${product}`;
// 表示モード保持キー（プロダクト別）
const displayStorageKey = `ccclog.displayMode.${product}`;

// 空データ判定（検索UI/スクリプトを出すかどうか）
const hasData = months.length > 0;

const legendItems = getLegendItems(product);
---

<BaseLayout
  title={`${productName} CHANGELOG Viewer - ${year}`}
  currentYear={year}
  years={years}
  product={product}
>
  {hasData ? (
    <>
      <SearchBox />

      <div class="info-bar">
        <ul class="legend" aria-label="カテゴリ凡例">
          {legendItems.map((item) => (
            <li class="legend-item">
              <span class={`legend-bar ${item.cls}`}></span>{item.label}
            </li>
          ))}
        </ul>
        <span class="generated-at">最終更新: {generatedDate}</span>
      </div>

      <div id="changelog-list">
        {months.map((month: MonthData, index: number) => (
          <MonthGroup
            monthKey={month.key}
            label={month.label}
            versions={month.versions}
            defaultOpen={index === 0}
            product={product}
          />
        ))}
      </div>

      <div id="no-results" class="no-results" hidden>
        <p>検索結果が見つかりませんでした。</p>
        <p>別のキーワードで検索してみてください。</p>
      </div>
    </>
  ) : (
    <div class="no-data">
      <p>データがありません。</p>
    </div>
  )}
</BaseLayout>

<script define:vars={{ storageKey, displayStorageKey, product }}>
  // 検索モード保持キーをクライアントサイドで使用
  window.__CCCLOG_STORAGE_KEY__ = storageKey;
  window.__CCCLOG_DISPLAY_STORAGE_KEY__ = displayStorageKey;
  window.__CCCLOG_PRODUCT_ID__ = product;
</script>

<script>
  import Fuse from 'fuse.js';
  import {
    formatEntryHtml,
    type ChangelogProductId,
    type EntryLanguage,
  } from '../lib/entry-html';
  import { formatXCopyText, resolveXCopyLanguage, type NonCopyDisplayMode } from '../lib/x-copy-format';

  // 空データ時は検索UIが存在しないため、IIFEでラップして早期リターン
  (function initSearch() {
  interface SearchableEntry {
    version: string;
    monthKey: string;
    entryIndex: number;
    ja: string;
    en: string;
  }

  // DOM要素を取得（空データ時は検索UIが存在しないため早期リターン）
  const searchInput = document.getElementById('search-input') as HTMLInputElement | null;
  if (!searchInput) return;
  // null ガード通過後、ネスト関数内でも non-null として扱えるようにする
  const input: HTMLInputElement = searchInput;

  const clearButton = document.getElementById('clear-search') as HTMLButtonElement;
  const searchStats = document.getElementById('search-stats') as HTMLDivElement;
  const noResults = document.getElementById('no-results') as HTMLDivElement;
  const modeButtons = document.querySelectorAll('.mode-btn') as NodeListOf<HTMLButtonElement>;
  const displayButtons = document.querySelectorAll('.display-btn') as NodeListOf<HTMLButtonElement>;
  const changelogList = document.getElementById('changelog-list');

  // 検索用データを準備
  const searchableEntries: SearchableEntry[] = [];
  const monthGroups = document.querySelectorAll('.month-group');
  const versionSections = document.querySelectorAll('.version-section');

  monthGroups.forEach((group) => {
    const monthKey = group.getAttribute('data-month') || '';
    const sections = group.querySelectorAll('.version-section');

    sections.forEach((section) => {
      const version = section.id.replace('v', '');
      const rows = section.querySelectorAll('.entry-row');

      rows.forEach((row, entryIndex) => {
        const ja = (row as HTMLElement).dataset.ja || '';
        const en = (row as HTMLElement).dataset.en || '';
        searchableEntries.push({ version, monthKey, entryIndex, ja, en });
      });
    });
  });

  // Fuse.jsインスタンスを作成
  type SearchMode = 'ja' | 'en' | 'both';
  type ProductId = ChangelogProductId;

  // プロダクト別の検索モードキー（define:varsから取得）
  const STORAGE_KEY = (window as any).__CCCLOG_STORAGE_KEY__ || 'ccclog.searchMode.claude-code';
  const LEGACY_KEY = 'ccclog.searchMode';

  // 旧キーからのマイグレーション（既存ユーザー向け、Claude Code のみ）
  if (STORAGE_KEY === 'ccclog.searchMode.claude-code') {
    const legacyValue = sessionStorage.getItem(LEGACY_KEY);
    if (legacyValue && !sessionStorage.getItem(STORAGE_KEY)) {
      sessionStorage.setItem(STORAGE_KEY, legacyValue);
      sessionStorage.removeItem(LEGACY_KEY);
    }
  }

  function normalizeSearchMode(raw: string | null): SearchMode {
    return raw === 'ja' || raw === 'en' || raw === 'both' ? raw : 'both';
  }

  function getInitialMode(): SearchMode {
    const params = new URLSearchParams(window.location.search);
    if (params.has('mode')) return normalizeSearchMode(params.get('mode'));
    return normalizeSearchMode(sessionStorage.getItem(STORAGE_KEY));
  }

  // 表示モード
  type DisplayMode = 'ja' | 'en' | 'both' | 'copy';
  const DISPLAY_STORAGE_KEY = (window as any).__CCCLOG_DISPLAY_STORAGE_KEY__ || 'ccclog.displayMode.claude-code';
  const PRODUCT_ID: ProductId = (window as any).__CCCLOG_PRODUCT_ID__ === 'codex' ? 'codex' : 'claude-code';
  const PRODUCT_NAME = PRODUCT_ID === 'codex' ? 'OpenAI Codex' : 'Claude Code';

  function normalizeDisplayMode(raw: string | null): DisplayMode {
    return raw === 'ja' || raw === 'en' || raw === 'both' || raw === 'copy' ? raw : 'both';
  }

  function getInitialDisplayMode(): DisplayMode {
    const params = new URLSearchParams(window.location.search);
    if (params.has('display')) return normalizeDisplayMode(params.get('display'));
    return normalizeDisplayMode(sessionStorage.getItem(DISPLAY_STORAGE_KEY));
  }

  function getVisibleRows(section: Element): HTMLElement[] {
    const rows = Array.from(section.querySelectorAll('.entry-row')) as HTMLElement[];
    const visibleRows = rows.filter((row) => !row.classList.contains('hidden'));
    return visibleRows.length > 0 ? visibleRows : rows;
  }

  function renderXCopyBlocks(sourceMode: NonCopyDisplayMode) {
    const language = resolveXCopyLanguage(sourceMode);

    versionSections.forEach((section) => {
      const xCopyText = section.querySelector('.x-copy-text') as HTMLElement | null;
      if (!xCopyText) return;

      const version = section.id.replace('v', '');
      const rows = getVisibleRows(section);
      const entries = rows.map((row) => ({
        ja: row.dataset.ja || '',
        en: row.dataset.en || '',
      }));

      xCopyText.textContent = formatXCopyText({
        productName: PRODUCT_NAME,
        version,
        entries,
        language,
      });
    });
  }

  function syncDisplayUI(mode: DisplayMode) {
    displayButtons.forEach((button) => {
      const isActive = button.dataset.display === mode;
      button.classList.toggle('active', isActive);
      button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
  }

  function applyDisplayMode(mode: DisplayMode) {
    if (!changelogList) return;
    changelogList.classList.remove('display-ja', 'display-en', 'display-copy');
    if (mode === 'ja') changelogList.classList.add('display-ja');
    else if (mode === 'en') changelogList.classList.add('display-en');
    else if (mode === 'copy') changelogList.classList.add('display-copy');
  }

  function createFuseInstance(mode: SearchMode) {
    const keys = mode === 'both' ? ['ja', 'en'] : [mode];
    return new Fuse(searchableEntries, {
      keys,
      threshold: 0.3,
      ignoreLocation: true,
    });
  }

  function syncModeUI(mode: SearchMode) {
    modeButtons.forEach((button) => {
      const isActive = button.dataset.mode === mode;
      button.classList.toggle('active', isActive);
      button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
  }

  function updateUrlParams(query: string, mode: SearchMode, display: DisplayMode) {
    const url = new URL(window.location.href);
    const trimmedQuery = query.trim();

    if (trimmedQuery) url.searchParams.set('q', trimmedQuery);
    else url.searchParams.delete('q');

    if (mode === 'both') url.searchParams.delete('mode');
    else url.searchParams.set('mode', mode);

    if (display === 'both') url.searchParams.delete('display');
    else url.searchParams.set('display', display);

    history.replaceState(null, '', url);
  }

  let currentMode: SearchMode = getInitialMode();
  syncModeUI(currentMode);
  sessionStorage.setItem(STORAGE_KEY, currentMode);

  let currentDisplayMode: DisplayMode = getInitialDisplayMode();
  let lastNonCopyDisplayMode: NonCopyDisplayMode =
    currentDisplayMode === 'copy' ? 'both' : currentDisplayMode;
  syncDisplayUI(currentDisplayMode);
  applyDisplayMode(currentDisplayMode);
  if (currentDisplayMode === 'copy') renderXCopyBlocks(lastNonCopyDisplayMode);
  sessionStorage.setItem(DISPLAY_STORAGE_KEY, currentDisplayMode);

  let fuse = createFuseInstance(currentMode);

  function isExactCellMatch(rawText: string, query: string, key: 'ja' | 'en'): boolean {
    const trimmedQuery = query.trim();
    if (!trimmedQuery) return false;

    const trimmedText = rawText.trim();
    if (key === 'en') {
      return trimmedText.toLocaleLowerCase() === trimmedQuery.toLocaleLowerCase();
    }
    return trimmedText === trimmedQuery;
  }

  function setCellHtml(element: HTMLElement, rawText: string, language: EntryLanguage, highlight: boolean) {
    const rendered = formatEntryHtml(rawText, { product: PRODUCT_ID, language });
    element.innerHTML = highlight ? `<span class="highlight">${rendered}</span>` : rendered;
  }

  function applyRowHighlight(
    row: Element,
    query: string,
    mode: SearchMode
  ) {
    const jaCell = row.querySelector('.entry-ja') as HTMLElement;
    const enCell = row.querySelector('.entry-en') as HTMLElement;
    const rawJa = (row as HTMLElement).dataset.ja || '';
    const rawEn = (row as HTMLElement).dataset.en || '';

    if (mode === 'ja') {
      if (jaCell) setCellHtml(jaCell, rawJa, 'ja', isExactCellMatch(rawJa, query, 'ja'));
      if (enCell) setCellHtml(enCell, rawEn, 'en', false);
      return;
    }

    if (mode === 'en') {
      if (enCell) setCellHtml(enCell, rawEn, 'en', isExactCellMatch(rawEn, query, 'en'));
      if (jaCell) setCellHtml(jaCell, rawJa, 'ja', false);
      return;
    }

    if (jaCell) setCellHtml(jaCell, rawJa, 'ja', isExactCellMatch(rawJa, query, 'ja'));
    if (enCell) setCellHtml(enCell, rawEn, 'en', isExactCellMatch(rawEn, query, 'en'));
  }

  function setSearchMode(mode: SearchMode) {
    currentMode = mode;
    sessionStorage.setItem(STORAGE_KEY, mode);
    syncModeUI(mode);
    fuse = createFuseInstance(mode);
    performSearch(input.value);
  }

  function setDisplayMode(mode: DisplayMode) {
    if (mode !== 'copy') {
      lastNonCopyDisplayMode = mode;
    }
    currentDisplayMode = mode;
    sessionStorage.setItem(DISPLAY_STORAGE_KEY, mode);
    syncDisplayUI(mode);
    applyDisplayMode(mode);
    if (mode === 'copy') {
      renderXCopyBlocks(lastNonCopyDisplayMode);
    }
    updateUrlParams(input.value, currentMode, currentDisplayMode);
  }

  // 検索を実行
  function performSearch(query: string) {
    const trimmedQuery = query.trim();

    // 検索クリアボタンの表示制御
    clearButton.hidden = !trimmedQuery;

    if (!trimmedQuery) {
      // 検索クリア: すべて表示
      monthGroups.forEach((group) => group.classList.remove('hidden'));
      versionSections.forEach((section) => {
        section.classList.remove('hidden');
        const rows = section.querySelectorAll('.entry-row');
        rows.forEach((row) => {
          row.classList.remove('hidden');
          // ハイライトをリセット
          applyRowHighlight(row, '', currentMode);
        });
      });
      searchStats.hidden = true;
      noResults.hidden = true;
      if (currentDisplayMode === 'copy') {
        renderXCopyBlocks(lastNonCopyDisplayMode);
      }
      updateUrlParams('', currentMode, currentDisplayMode);
      return;
    }

    // 検索実行
    const results = fuse.search(trimmedQuery);
    const matchedVersions = new Set<string>();
    const matchedMonths = new Set<string>();
    const matchedEntries = new Map<string, Set<number>>();
    results.forEach((r) => {
      const { version, monthKey, entryIndex } = r.item;
      matchedVersions.add(version);
      matchedMonths.add(monthKey);

      const versionKey = `v${version}`;
      if (!matchedEntries.has(versionKey)) {
        matchedEntries.set(versionKey, new Set());
      }
      matchedEntries.get(versionKey)!.add(entryIndex);
    });

    // UIを更新
    let visibleEntryCount = 0;

    monthGroups.forEach((group) => {
      const monthKey = group.getAttribute('data-month') || '';
      if (matchedMonths.has(monthKey)) {
        group.classList.remove('hidden');
        // 折りたたみを開く
        const details = group.querySelector('details');
        if (details) details.open = true;
      } else {
        group.classList.add('hidden');
      }
    });

    versionSections.forEach((section) => {
      const version = section.id;
      const versionNum = version.replace('v', '');

      if (matchedVersions.has(versionNum)) {
        section.classList.remove('hidden');
        const rows = section.querySelectorAll('.entry-row');
        const matchedIndices = matchedEntries.get(version) || new Set();

        rows.forEach((row, idx) => {
          if (matchedIndices.has(idx)) {
            row.classList.remove('hidden');
            visibleEntryCount++;
            applyRowHighlight(row, trimmedQuery, currentMode);
          } else {
            row.classList.add('hidden');
          }
        });
      } else {
        section.classList.add('hidden');
      }
    });

    // 検索統計を表示
    if (visibleEntryCount > 0) {
      searchStats.innerHTML = `<span class="match-count">${visibleEntryCount}</span> 件の結果`;
      searchStats.hidden = false;
      noResults.hidden = true;
    } else {
      searchStats.hidden = true;
      noResults.hidden = false;
    }

    if (currentDisplayMode === 'copy') {
      renderXCopyBlocks(lastNonCopyDisplayMode);
    }

    updateUrlParams(trimmedQuery, currentMode, currentDisplayMode);
  }

  // イベントリスナーを設定
  let debounceTimer: number;

  input.addEventListener('input', () => {
    clearTimeout(debounceTimer);
    debounceTimer = window.setTimeout(() => {
      performSearch(input.value);
    }, 150);
  });

  clearButton.addEventListener('click', () => {
    input.value = '';
    performSearch('');
    input.focus();
  });

  // Escapeキーで検索をクリア
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      input.value = '';
      performSearch('');
    }
  });

  modeButtons.forEach((button) => {
    button.addEventListener('click', () => {
      const nextMode = normalizeSearchMode(button.dataset.mode || null);
      if (nextMode !== currentMode) setSearchMode(nextMode);
    });
  });

  displayButtons.forEach((button) => {
    button.addEventListener('click', () => {
      const nextDisplay = normalizeDisplayMode(button.dataset.display || null);
      if (nextDisplay !== currentDisplayMode) setDisplayMode(nextDisplay);
    });
  });

  // ページ読み込み時にURLパラメータから検索クエリを復元
  const urlParams = new URLSearchParams(window.location.search);
  const initialQuery = urlParams.get('q');
  if (initialQuery) {
    input.value = initialQuery;
    performSearch(initialQuery);
  } else {
    updateUrlParams('', currentMode, currentDisplayMode);
  }
  })();
</script>

<style>
  .info-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
    margin-bottom: 1.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--color-border);
  }

  .generated-at {
    color: var(--color-text-muted);
    font-size: 0.8rem;
  }

  .legend {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .legend-item {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    font-size: 0.8rem;
    color: var(--color-text-muted);
  }

  .legend-bar {
    display: inline-block;
    width: 3px;
    height: 14px;
    border-radius: 1px;
  }

  .legend-bar.added { background-color: var(--color-added); }
  .legend-bar.fixed { background-color: var(--color-fixed); }
  .legend-bar.changed { background-color: var(--color-changed); }
  .legend-bar.improved { background-color: var(--color-improved); }
  .legend-bar.other { background-color: var(--color-other); }

  @media (max-width: 768px) {
    .info-bar {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
    }
  }

  .no-results {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--color-text-muted);
  }

  .no-results p {
    margin-bottom: 0.5rem;
  }

  .no-results:not([hidden]) {
    display: block;
  }

  .no-data {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--color-text-muted);
  }
</style>
