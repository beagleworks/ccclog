---
/**
 * ChangelogPage - 年別ページの共通コンポーネント
 *
 * トップページ（/、/codex/）と年別ページ（/{year}/、/codex/{year}/）で共通で使用。
 * 検索機能、月別グループ表示、スタイルを含む。
 */
import BaseLayout from '../layouts/BaseLayout.astro';
import SearchBox from './SearchBox.astro';
import MonthGroup from './MonthGroup.astro';
import { getLegendItems } from '../lib/legend';

interface MonthData {
  key: string;
  label: string;
  versions: any[];
}

interface SearchIndexDoc {
  id: number;
  version: string;
  monthKey: string;
  entryIndex: number;
  ja: string;
  en: string;
}

interface SearchIndexData {
  version: number;
  product: 'claude-code' | 'codex';
  year: string;
  docs: SearchIndexDoc[];
  enTokenToDocIds: Record<string, number[]>;
  ja2gramToDocIds: Record<string, number[]>;
}

interface Props {
  year: string;
  years: string[];
  months: MonthData[];
  generatedAt?: string;
  product?: 'claude-code' | 'codex';
  searchIndex?: SearchIndexData;
}

const {
  year,
  years,
  months,
  generatedAt,
  product = 'claude-code',
  searchIndex,
} = Astro.props;

const generatedDate =
  typeof generatedAt === 'string' && Number.isFinite(Date.parse(generatedAt))
    ? new Date(generatedAt).toLocaleString('ja-JP', {
        timeZone: 'Asia/Tokyo',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
      })
    : '不明';

const productName = product === 'codex' ? 'OpenAI Codex' : 'Claude Code';

// 検索モード保持キー（プロダクト別）
const storageKey = `ccclog.searchMode.${product}`;
// 表示モード保持キー（プロダクト別）
const displayStorageKey = `ccclog.displayMode.${product}`;
// 表示形式（プレーン）保持キー（プロダクト別）
const plainStorageKey = `ccclog.plainMode.${product}`;

// 空データ判定（検索UI/スクリプトを出すかどうか）
const hasData = months.length > 0;

const legendItems = getLegendItems(product);

const emptySearchIndex: SearchIndexData = {
  version: 1,
  product,
  year,
  docs: [],
  enTokenToDocIds: {},
  ja2gramToDocIds: {},
};
const effectiveSearchIndex = searchIndex ?? emptySearchIndex;
const searchIndexJson = JSON.stringify(effectiveSearchIndex).replace(/</g, '\\u003c');
---

<BaseLayout
  title={`${productName} CHANGELOG Viewer - ${year}`}
  currentYear={year}
  years={years}
  product={product}
>
  {hasData ? (
    <>
      <SearchBox />

      <div class="info-bar">
        <ul class="legend" aria-label="カテゴリ凡例">
          {legendItems.map((item) => (
            <li class="legend-item">
              <span class={`legend-bar ${item.cls}`}></span>{item.label}
            </li>
          ))}
        </ul>
        <span class="generated-at">最終更新: {generatedDate}</span>
      </div>

      <div id="changelog-list">
        {months.map((month: MonthData, index: number) => (
          <MonthGroup
            monthKey={month.key}
            label={month.label}
            versions={month.versions}
            defaultOpen={index === 0}
            product={product}
          />
        ))}
      </div>

      <div id="no-results" class="no-results" hidden>
        <p>検索結果が見つかりませんでした。</p>
        <p>別のキーワードで検索してみてください。</p>
      </div>

      <script id="search-index-data" type="application/json" set:html={searchIndexJson}></script>
    </>
  ) : (
    <div class="no-data">
      <p>データがありません。</p>
    </div>
  )}
</BaseLayout>

<script define:vars={{ storageKey, displayStorageKey, plainStorageKey, product }}>
  // 検索モード保持キーをクライアントサイドで使用
  window.__CCCLOG_STORAGE_KEY__ = storageKey;
  window.__CCCLOG_DISPLAY_STORAGE_KEY__ = displayStorageKey;
  window.__CCCLOG_PLAIN_STORAGE_KEY__ = plainStorageKey;
  window.__CCCLOG_PRODUCT_ID__ = product;
</script>

<script>
  import {
    formatEntryHtml,
    type ChangelogProductId,
  } from '../lib/entry-html';
  import { applyEnglishTokenHighlights, applyJapaneseSubstringHighlights } from '../lib/dom-highlight';
  import {
    applyRowHighlight as applyRowHighlightRuntime,
    resetToAllRows as resetToAllRowsRuntime,
    type SearchMode as RuntimeSearchMode,
  } from '../lib/changelog-search-runtime';
  import { formatXCopyText, resolveXCopyLanguage, type NonCopyDisplayMode } from '../lib/x-copy-format';
  import {
    isSingleJapaneseCharacterQuery,
    normalizeJapaneseText,
    toJapaneseBigrams,
    tokenizeEnglish,
    toUniqueTokens,
  } from '../lib/search-normalize';

  // 空データ時は検索UIが存在しないため、IIFEでラップして早期リターン
  (function initSearch() {
  interface SearchIndexDoc {
    id: number;
    version: string;
    monthKey: string;
    entryIndex: number;
    ja: string;
    en: string;
  }

  interface SearchIndexData {
    version: number;
    product: 'claude-code' | 'codex';
    year: string;
    docs: SearchIndexDoc[];
    enTokenToDocIds: Record<string, number[]>;
    ja2gramToDocIds: Record<string, number[]>;
  }

  type SearchMode = RuntimeSearchMode;
  type ProductId = ChangelogProductId;
  type DisplayMode = NonCopyDisplayMode;

  // DOM要素を取得（空データ時は検索UIが存在しないため早期リターン）
  const searchInput = document.getElementById('search-input') as HTMLInputElement | null;
  if (!searchInput) return;
  // null ガード通過後、ネスト関数内でも non-null として扱えるようにする
  const input: HTMLInputElement = searchInput;

  const clearButton = document.getElementById('clear-search') as HTMLButtonElement;
  const searchStats = document.getElementById('search-stats') as HTMLDivElement;
  const noResults = document.getElementById('no-results') as HTMLDivElement;
  const modeButtons = document.querySelectorAll<HTMLButtonElement>('.mode-btn');
  const displayButtons = document.querySelectorAll<HTMLButtonElement>('.display-btn');
  const changelogList = document.getElementById('changelog-list');
  const monthGroups = document.querySelectorAll<HTMLElement>('.month-group');
  const versionSections = document.querySelectorAll<HTMLElement>('.version-section');

  let searchAvailable = true;
  function markSearchUnavailable(message: string, error?: unknown) {
    searchAvailable = false;
    console.error(`[search] ${message}`, error);
    input.disabled = true;
    input.placeholder = '検索機能をロードできませんでした';
    clearButton.hidden = true;
    modeButtons.forEach((button) => {
      button.disabled = true;
    });
    searchStats.innerHTML = `<span class="no-results">${message}</span>`;
    searchStats.hidden = false;
    noResults.hidden = true;
  }

  const emptySearchIndex: SearchIndexData = {
    version: 1,
    product: 'claude-code',
    year: '',
    docs: [],
    enTokenToDocIds: {},
    ja2gramToDocIds: {},
  };

  const searchIndexElement = document.getElementById('search-index-data');
  let searchIndex: SearchIndexData = emptySearchIndex;
  if (!searchIndexElement?.textContent) {
    markSearchUnavailable('検索機能をロードできませんでした（データが見つかりません）');
  } else {
    try {
      searchIndex = JSON.parse(searchIndexElement.textContent) as SearchIndexData;
    } catch (error) {
      markSearchUnavailable('検索機能をロードできませんでした（データが壊れています）', error);
    }
  }

  const docsById = new Map<number, SearchIndexDoc>();
  const rowByCompositeKey = new Map<string, HTMLElement>();
  const rowByDocId = new Map<number, HTMLElement>();
  const docEnTokensById = new Map<number, Set<string>>();
  const docJaNormalizedById = new Map<number, string>();

  function makeCompositeKey(monthKey: string, version: string, entryIndex: number): string {
    return `${monthKey}::${version}::${entryIndex}`;
  }

  function toPostingMap(record: Record<string, number[]>): Map<string, Set<number>> {
    const map = new Map<string, Set<number>>();
    Object.entries(record).forEach(([token, ids]) => {
      map.set(token, new Set(ids));
    });
    return map;
  }

  monthGroups.forEach((group) => {
    const monthKey = group.dataset.month || '';
    const sections = group.querySelectorAll<HTMLElement>('.version-section');

    sections.forEach((section) => {
      const version = section.id.replace('v', '');
      const rows = section.querySelectorAll<HTMLElement>('.entry-row');

      rows.forEach((row, entryIndex) => {
        rowByCompositeKey.set(makeCompositeKey(monthKey, version, entryIndex), row);
      });
    });
  });

  searchIndex.docs.forEach((doc) => {
    docsById.set(doc.id, doc);
    docEnTokensById.set(doc.id, new Set(toUniqueTokens(tokenizeEnglish(doc.en))));
    docJaNormalizedById.set(doc.id, normalizeJapaneseText(doc.ja));

    const row = rowByCompositeKey.get(makeCompositeKey(doc.monthKey, doc.version, doc.entryIndex));
    if (row) {
      rowByDocId.set(doc.id, row);
    }
  });

  const enPosting = toPostingMap(searchIndex.enTokenToDocIds);
  const jaPosting = toPostingMap(searchIndex.ja2gramToDocIds);

  // プロダクト別の検索モードキー（define:varsから取得）
  const STORAGE_KEY = (window as any).__CCCLOG_STORAGE_KEY__ || 'ccclog.searchMode.claude-code';
  const LEGACY_KEY = 'ccclog.searchMode';

  // 旧キーからのマイグレーション（既存ユーザー向け、Claude Code のみ）
  if (STORAGE_KEY === 'ccclog.searchMode.claude-code') {
    const legacyValue = sessionStorage.getItem(LEGACY_KEY);
    if (legacyValue && !sessionStorage.getItem(STORAGE_KEY)) {
      sessionStorage.setItem(STORAGE_KEY, legacyValue);
      sessionStorage.removeItem(LEGACY_KEY);
    }
  }

  function normalizeSearchMode(raw: string | null): SearchMode {
    return raw === 'ja' || raw === 'en' || raw === 'both' ? raw : 'both';
  }

  function getInitialMode(): SearchMode {
    const params = new URLSearchParams(window.location.search);
    if (params.has('mode')) return normalizeSearchMode(params.get('mode'));
    return normalizeSearchMode(sessionStorage.getItem(STORAGE_KEY));
  }

  const DISPLAY_STORAGE_KEY = (window as any).__CCCLOG_DISPLAY_STORAGE_KEY__ || 'ccclog.displayMode.claude-code';
  const PLAIN_STORAGE_KEY = (window as any).__CCCLOG_PLAIN_STORAGE_KEY__ || 'ccclog.plainMode.claude-code';
  const PRODUCT_ID: ProductId = (window as any).__CCCLOG_PRODUCT_ID__ === 'codex' ? 'codex' : 'claude-code';
  const PRODUCT_NAME = PRODUCT_ID === 'codex' ? 'OpenAI Codex' : 'Claude Code';
  const plainToggle = document.getElementById('plain-toggle') as HTMLInputElement | null;

  function normalizeDisplayMode(raw: string | null): DisplayMode {
    return raw === 'ja' || raw === 'en' || raw === 'both' ? raw : 'both';
  }

  function getInitialDisplayMode(): DisplayMode {
    const params = new URLSearchParams(window.location.search);
    // 旧URL互換: ?display=copy は plain=ON とみなし、表示モードは both
    if (params.get('display') === 'copy') return 'both';
    if (params.has('display')) return normalizeDisplayMode(params.get('display'));
    return normalizeDisplayMode(sessionStorage.getItem(DISPLAY_STORAGE_KEY));
  }

  function normalizePlainValue(raw: string | null): boolean {
    return raw === '1' || raw === 'true';
  }

  function normalizePlainParam(raw: string | null): boolean {
    if (raw === null) return false;
    if (raw === '' || raw === '1' || raw === 'true' || raw === 'on') return true;
    return false;
  }

  function getInitialPlainMode(): boolean {
    const params = new URLSearchParams(window.location.search);
    if (params.has('plain')) return normalizePlainParam(params.get('plain'));
    // 旧URL互換: ?display=copy は plain=ON として扱う
    if (params.get('display') === 'copy') return true;
    return normalizePlainValue(sessionStorage.getItem(PLAIN_STORAGE_KEY));
  }

  function getVisibleRows(section: Element): HTMLElement[] {
    const rows = Array.from(section.querySelectorAll<HTMLElement>('.entry-row'));
    const visibleRows = rows.filter((row) => !row.classList.contains('hidden'));
    return visibleRows.length > 0 ? visibleRows : rows;
  }

  function renderPlainBlocks(sourceMode: NonCopyDisplayMode) {
    const language = resolveXCopyLanguage(sourceMode);

    versionSections.forEach((section) => {
      const plainText = section.querySelector('.plain-text') as HTMLElement | null;
      if (!plainText) return;

      const version = section.id.replace('v', '');
      const rows = getVisibleRows(section);
      const entries = rows.map((row) => ({
        ja: row.dataset.ja || '',
        en: row.dataset.en || '',
      }));

      plainText.textContent = formatXCopyText({
        productName: PRODUCT_NAME,
        version,
        entries,
        language,
      });
    });
  }

  function syncDisplayUI(mode: DisplayMode) {
    displayButtons.forEach((button) => {
      const isActive = button.dataset.display === mode;
      button.classList.toggle('active', isActive);
      button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
  }

  function applyDisplayMode(mode: DisplayMode) {
    if (!changelogList) return;
    changelogList.classList.remove('display-ja', 'display-en');
    if (mode === 'ja') changelogList.classList.add('display-ja');
    else if (mode === 'en') changelogList.classList.add('display-en');
  }

  function syncPlainUI(enabled: boolean) {
    if (!plainToggle) return;
    plainToggle.checked = enabled;
  }

  function applyPlainMode(enabled: boolean) {
    if (!changelogList) return;
    changelogList.classList.toggle('plain-mode', enabled);
  }

  function syncModeUI(mode: SearchMode) {
    modeButtons.forEach((button) => {
      const isActive = button.dataset.mode === mode;
      button.classList.toggle('active', isActive);
      button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
  }

  function updateUrlParams(query: string, mode: SearchMode, display: DisplayMode, plain: boolean) {
    const url = new URL(window.location.href);
    const trimmedQuery = query.trim();

    if (trimmedQuery) url.searchParams.set('q', trimmedQuery);
    else url.searchParams.delete('q');

    if (mode === 'both') url.searchParams.delete('mode');
    else url.searchParams.set('mode', mode);

    if (display === 'both') url.searchParams.delete('display');
    else url.searchParams.set('display', display);

    if (plain) url.searchParams.set('plain', '1');
    else url.searchParams.delete('plain');

    history.replaceState(null, '', url);
  }

  let currentMode: SearchMode = getInitialMode();
  syncModeUI(currentMode);
  sessionStorage.setItem(STORAGE_KEY, currentMode);

  let currentDisplayMode: DisplayMode = getInitialDisplayMode();
  let isPlainMode = getInitialPlainMode();
  syncDisplayUI(currentDisplayMode);
  applyDisplayMode(currentDisplayMode);
  syncPlainUI(isPlainMode);
  applyPlainMode(isPlainMode);
  if (isPlainMode) renderPlainBlocks(currentDisplayMode);
  sessionStorage.setItem(DISPLAY_STORAGE_KEY, currentDisplayMode);
  sessionStorage.setItem(PLAIN_STORAGE_KEY, isPlainMode ? '1' : '0');

  function intersectDocIds(postings: Set<number>[]): Set<number> {
    if (postings.length === 0) return new Set();

    const sorted = [...postings].sort((a, b) => a.size - b.size);
    const [smallest, ...rest] = sorted;
    const intersected = new Set<number>();

    smallest.forEach((docId) => {
      if (rest.every((posting) => posting.has(docId))) {
        intersected.add(docId);
      }
    });

    return intersected;
  }

  function unionDocIds(left: Set<number>, right: Set<number>): Set<number> {
    const union = new Set(left);
    right.forEach((docId) => union.add(docId));
    return union;
  }

  function searchEnglishDocIds(queryTokens: string[]): Set<number> {
    if (queryTokens.length === 0) return new Set();

    const postings: Set<number>[] = [];
    for (const token of queryTokens) {
      const posting = enPosting.get(token);
      if (!posting) return new Set();
      postings.push(posting);
    }

    const candidates = intersectDocIds(postings);
    const matched = new Set<number>();
    candidates.forEach((docId) => {
      const docTokenSet = docEnTokensById.get(docId);
      if (docTokenSet && queryTokens.every((token) => docTokenSet.has(token))) {
        matched.add(docId);
      }
    });
    return matched;
  }

  function searchJapaneseDocIds(query: string): { ids: Set<number>; short: boolean } {
    if (isSingleJapaneseCharacterQuery(query)) {
      return { ids: new Set(), short: true };
    }

    const normalizedQuery = normalizeJapaneseText(query);
    if (!normalizedQuery) {
      return { ids: new Set(), short: false };
    }

    const queryBigrams = toUniqueTokens(toJapaneseBigrams(normalizedQuery));
    if (queryBigrams.length === 0) {
      return { ids: new Set(), short: false };
    }

    const postings: Set<number>[] = [];
    for (const gram of queryBigrams) {
      const posting = jaPosting.get(gram);
      if (!posting) return { ids: new Set(), short: false };
      postings.push(posting);
    }

    const candidates = intersectDocIds(postings);
    const matched = new Set<number>();
    candidates.forEach((docId) => {
      const normalizedJa = docJaNormalizedById.get(docId);
      if (normalizedJa?.includes(normalizedQuery)) {
        matched.add(docId);
      }
    });
    return { ids: matched, short: false };
  }

  function matchesEnglishCell(rawText: string, queryTokens: string[]): boolean {
    if (queryTokens.length === 0) return false;
    const textTokenSet = new Set(toUniqueTokens(tokenizeEnglish(rawText)));
    return queryTokens.every((token) => textTokenSet.has(token));
  }

  function matchesJapaneseCell(rawText: string, query: string, allowSingleJapanese: boolean): boolean {
    if (!allowSingleJapanese && isSingleJapaneseCharacterQuery(query)) {
      return false;
    }

    const normalizedQuery = normalizeJapaneseText(query);
    if (!normalizedQuery) return false;
    const normalizedText = normalizeJapaneseText(rawText);
    return normalizedText.includes(normalizedQuery);
  }

  function setJapaneseCellHtml(element: HTMLElement, rawText: string, query: string, highlight: boolean) {
    const rendered = formatEntryHtml(rawText, { product: PRODUCT_ID, language: 'ja' });
    element.innerHTML = rendered;
    if (highlight) {
      applyJapaneseSubstringHighlights(element, query);
    }
  }

  function setEnglishCellHtml(element: HTMLElement, rawText: string, queryTokens: string[]) {
    const rendered = formatEntryHtml(rawText, { product: PRODUCT_ID, language: 'en' });
    element.innerHTML = rendered;
    if (queryTokens.length > 0) {
      applyEnglishTokenHighlights(element, queryTokens);
    }
  }

  function applyRowHighlight(
    row: HTMLElement,
    query: string,
    mode: SearchMode,
    allowSingleJapanese: boolean,
    englishQueryTokens: string[]
  ) {
    applyRowHighlightRuntime({
      row,
      query,
      mode,
      allowSingleJapanese,
      englishQueryTokens,
      matchesEnglishCell,
      matchesJapaneseCell,
      setJapaneseCellHtml,
      setEnglishCellHtml,
    });
  }

  function resetToAllRows() {
    resetToAllRowsRuntime({
      monthGroups,
      versionSections,
      resetRowHighlight: (row) => {
        applyRowHighlight(row, '', currentMode, true, []);
      },
    });
  }

  function setSearchMode(mode: SearchMode) {
    if (!searchAvailable) return;
    currentMode = mode;
    sessionStorage.setItem(STORAGE_KEY, mode);
    syncModeUI(mode);
    performSearch(input.value);
  }

  function setDisplayMode(mode: DisplayMode) {
    currentDisplayMode = mode;
    sessionStorage.setItem(DISPLAY_STORAGE_KEY, mode);
    syncDisplayUI(mode);
    applyDisplayMode(mode);
    if (isPlainMode) renderPlainBlocks(mode);
    updateUrlParams(input.value, currentMode, currentDisplayMode, isPlainMode);
  }

  function setPlainMode(enabled: boolean) {
    isPlainMode = enabled;
    sessionStorage.setItem(PLAIN_STORAGE_KEY, enabled ? '1' : '0');
    syncPlainUI(enabled);
    applyPlainMode(enabled);
    if (enabled) renderPlainBlocks(currentDisplayMode);
    updateUrlParams(input.value, currentMode, currentDisplayMode, enabled);
  }

  // 検索を実行
  function performSearch(query: string) {
    if (!searchAvailable) return;

    const trimmedQuery = query.trim();

    // 検索クリアボタンの表示制御
    clearButton.hidden = !trimmedQuery;

    if (!trimmedQuery) {
      resetToAllRows();
      searchStats.hidden = true;
      noResults.hidden = true;
      if (isPlainMode) {
        renderPlainBlocks(currentDisplayMode);
      }
      updateUrlParams('', currentMode, currentDisplayMode, isPlainMode);
      return;
    }

    const englishQueryTokens = currentMode === 'ja' ? [] : toUniqueTokens(tokenizeEnglish(trimmedQuery));
    const englishMatches = currentMode === 'ja' ? new Set<number>() : searchEnglishDocIds(englishQueryTokens);
    const japaneseResult = currentMode === 'en'
      ? { ids: new Set<number>(), short: false }
      : searchJapaneseDocIds(trimmedQuery);

    const showJapaneseSearchHint = currentMode !== 'en' && japaneseResult.short;

    if (currentMode === 'ja' && japaneseResult.short) {
      resetToAllRows();
      searchStats.innerHTML = '<span class="no-results">日本語検索は2文字以上で入力してください</span>';
      searchStats.hidden = false;
      noResults.hidden = true;
      if (isPlainMode) {
        renderPlainBlocks(currentDisplayMode);
      }
      updateUrlParams(trimmedQuery, currentMode, currentDisplayMode, isPlainMode);
      return;
    }

    if (currentMode === 'both' && japaneseResult.short && englishMatches.size === 0) {
      resetToAllRows();
      searchStats.innerHTML = '<span class="no-results">日本語検索は2文字以上で入力してください</span>';
      searchStats.hidden = false;
      noResults.hidden = true;
      if (isPlainMode) {
        renderPlainBlocks(currentDisplayMode);
      }
      updateUrlParams(trimmedQuery, currentMode, currentDisplayMode, isPlainMode);
      return;
    }

    const matchedDocIds = currentMode === 'ja'
      ? japaneseResult.ids
      : currentMode === 'en'
      ? englishMatches
      : unionDocIds(englishMatches, japaneseResult.ids);

    const matchedSections = new Set<string>();
    const matchedMonths = new Set<string>();
    let visibleEntryCount = 0;

    monthGroups.forEach((group) => group.classList.add('hidden'));
    versionSections.forEach((section) => {
      section.classList.add('hidden');
      section.querySelectorAll<HTMLElement>('.entry-row').forEach((row) => {
        row.classList.add('hidden');
      });
    });

    matchedDocIds.forEach((docId) => {
      const doc = docsById.get(docId);
      const row = rowByDocId.get(docId);
      if (!doc || !row) return;

      row.classList.remove('hidden');
      matchedSections.add(`v${doc.version}`);
      matchedMonths.add(doc.monthKey);
      visibleEntryCount += 1;
      applyRowHighlight(row, trimmedQuery, currentMode, !japaneseResult.short, englishQueryTokens);
    });

    versionSections.forEach((section) => {
      if (matchedSections.has(section.id)) {
        section.classList.remove('hidden');
      }
    });

    monthGroups.forEach((group) => {
      const monthKey = group.dataset.month || '';
      if (matchedMonths.has(monthKey)) {
        group.classList.remove('hidden');
        const details = group.querySelector('details');
        if (details) details.open = true;
      }
    });

    if (visibleEntryCount > 0) {
      const notice = showJapaneseSearchHint ? '（日本語検索は2文字以上で入力してください）' : '';
      searchStats.innerHTML = `<span class="match-count">${visibleEntryCount}</span> 件の結果${notice}`;
      searchStats.hidden = false;
      noResults.hidden = true;
    } else if (showJapaneseSearchHint) {
      searchStats.innerHTML = '<span class="no-results">日本語検索は2文字以上で入力してください</span>';
      searchStats.hidden = false;
      noResults.hidden = true;
    } else {
      searchStats.hidden = true;
      noResults.hidden = false;
    }

    if (isPlainMode) {
      renderPlainBlocks(currentDisplayMode);
    }

    updateUrlParams(trimmedQuery, currentMode, currentDisplayMode, isPlainMode);
  }

  // イベントリスナーを設定
  let debounceTimer: number;

  if (searchAvailable) {
    input.addEventListener('input', () => {
      clearTimeout(debounceTimer);
      debounceTimer = window.setTimeout(() => {
        performSearch(input.value);
      }, 150);
    });

    clearButton.addEventListener('click', () => {
      input.value = '';
      performSearch('');
      input.focus();
    });

    // Escapeキーで検索をクリア
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        input.value = '';
        performSearch('');
      }
    });

    modeButtons.forEach((button) => {
      button.addEventListener('click', () => {
        const nextMode = normalizeSearchMode(button.dataset.mode || null);
        if (nextMode !== currentMode) setSearchMode(nextMode);
      });
    });
  }

  displayButtons.forEach((button) => {
    button.addEventListener('click', () => {
      const nextDisplay = normalizeDisplayMode(button.dataset.display || null);
      if (nextDisplay !== currentDisplayMode) setDisplayMode(nextDisplay);
    });
  });

  plainToggle?.addEventListener('change', () => {
    setPlainMode(plainToggle.checked);
  });

  // ページ読み込み時にURLパラメータから検索クエリを復元
  const urlParams = new URLSearchParams(window.location.search);
  const initialQuery = urlParams.get('q');
  if (searchAvailable) {
    if (initialQuery) {
      input.value = initialQuery;
      performSearch(initialQuery);
    } else {
      updateUrlParams('', currentMode, currentDisplayMode, isPlainMode);
    }
  }
  })();
</script>

<style>
  .info-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
    margin-bottom: 1.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--color-border);
  }

  .generated-at {
    color: var(--color-text-muted);
    font-size: 0.8rem;
  }

  .legend {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .legend-item {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    font-size: 0.8rem;
    color: var(--color-text-muted);
  }

  .legend-bar {
    display: inline-block;
    width: 3px;
    height: 14px;
    border-radius: 1px;
  }

  .legend-bar.added { background-color: var(--color-added); }
  .legend-bar.fixed { background-color: var(--color-fixed); }
  .legend-bar.changed { background-color: var(--color-changed); }
  .legend-bar.improved { background-color: var(--color-improved); }
  .legend-bar.other { background-color: var(--color-other); }

  @media (max-width: 768px) {
    .info-bar {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
    }
  }

  .no-results {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--color-text-muted);
  }

  .no-results p {
    margin-bottom: 0.5rem;
  }

  .no-results:not([hidden]) {
    display: block;
  }

  .no-data {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--color-text-muted);
  }
</style>
